import sklearn.model_selection as model_selectionimport _config_randomized_searchimport scipy.statsfrom numpy import NaNimport osclass RandomizedSearch():    def __init__(self, estimator, hyperparameter_space,                 dataset_name, verbose=0):        self.cv = _config_randomized_search.cv_folds        self.n_iter = _config_randomized_search.n_iter        self.estimator = estimator        self.dataset_name = dataset_name         self.verbose = verbose                    param_dist = self.create_param_distributions(hyperparameter_space)                        self.rs = model_selection.RandomizedSearchCV(                      estimator,                      param_distributions=param_dist,                      n_iter=self.n_iter,                      error_score=NaN,                                       cv=self.cv)                                                  def fit(self, X, y):        file_name = "results"+os.sep+type(self.estimator).__name__+"_RandomizedSearch_"+self.dataset_name+".res"        f = open(file_name, "w")                        f.write("# Parameter search: Randomized Search (scikit-learn)\n"+                 "# Dataset: "+str(self.dataset_name)+"\n"+                "# Estimator: "+type(self.estimator).__name__+"\n")                               f.write("# Cross Validation: "+str(self.cv)+"\n")        f.write("#\n")        f.close()                self.rs.fit(X, y)        f = open(file_name, "a")                                              f.write("# Randomized scores on development set:\n\n")        means = self.rs.cv_results_['mean_test_score']        stds = self.rs.cv_results_['std_test_score']        for mean, std, params in zip(means, stds, self.rs.cv_results_['params']):            f.write("%0.3f (+/-%0.03f) for %r"                  % (mean, std * 2, params))            f.write("\n")        f.write("\n\n# Randomized Search finished.")        f.close()        print("Randomized Search finished.")            def create_param_distributions(self, hyperparameter_space):        ''' specify parameters and distributions to sample from            example:              param_dist = {"max_depth": [3, None],                  "max_features": sp_randint(1, 11),                  "min_samples_split": sp_randint(2, 11),                  "bootstrap": [True, False],                  "criterion": ["gini", "entropy"]}                          param_distributions : dict            Dictionary with parameters names (string) as keys and distributions            or lists of parameters to try. Distributions must provide a rvs             method for sampling (such as those from scipy.stats.distributions).            If a list is given, it is sampled uniformly.                    '''                       param_dict = {}        self.constant_params = {}                for param in hyperparameter_space.hyperparameters:            value = None                                    if param.__class__.__name__ == "FloatHyperparameter":                            value = scipy.stats.uniform(low=param.lower, high=param.upper)            if param.__class__.__name__ == "CategoricalHyperparameter":                value = param.value            if param.__class__.__name__ == "IntegerHyperparameter":                value = scipy.stats.randint(low=param.lower, high=param.upper)                            if param.__class__.__name__ == "Constant":                value = param.value[0]                # [0] ... there is only one value for the constant parameter                              param_dict[param.name] = value         if self.verbose > 0:            print ("Randomized search params:", end="")            print(param_dict)                                                                                                              return param_dict        